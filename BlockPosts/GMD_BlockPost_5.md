# Dev update 3: Progression System
In this post, I’ll walk through the work completed for Milestone 3 of my GMD1 game project. The goal was to implement weapon leveling, evolving enemy waves and finishing touches.  
ScriptableObjects have been essential for this development and are used for almost everything that evolves as the game progresses.

## Weapon Leveling  
As players defeat enemies, they gain XP. The player has a ScriptableObject defining how much XP the player needs to collect for each level.
```csharp
[CreateAssetMenu(fileName = "PlayerLevelSO", menuName = "Scriptable Objects/PlayerLevelSO")]
public class PlayerLevelSO : ScriptableObject
{
    public List<int> xpToLevelUp;
}
``` 
When enough XP is earned (based on values stored in a `PlayerLevelSO` ScriptableObject), the game pauses and a Level Up screen appears.

At this point, players are offered a choice between two random weapons to upgrade. These choices are generated by checking which weapons still have remaining levels and instantiating UI buttons for them.

Each weapon uses a ScriptableObject to define how its stats evolve. For example, the Splatter weapon references a `SplatterLevelDataSO`, which holds a list of `SplatterLevelData` objects, one for each level.
```csharp
[System.Serializable]
public class SplatterLevelData : LevelData
{
    public float attackSpeed;
    public float duration;
    public float tickRate;
    public float damage;
    public float size;
}
``` 

## Enemy Wave Evolution  
To keep up with the player’s growing power, the enemy waves evolve dynamically over time. This is managed by a `GamePhaseDataSO`, which defines a sequence of “phases,” each with a time threshold and different spawn intervals for various enemy types (normal, speed, giant).  
The actual wave logic lives in the `EnemyManager` class. As time progresses, the game moves into new phases by checking the elapsed time against the current phase’s `endTime`.
```csharp
 void Update()
 {
     currentTime += Time.deltaTime;
     if(currentTime> phaseData.Phases[gamePhase].endTime)
     {
         gamePhase++;
         UpdatePhase(gamePhase);
     }
...
``` 
The result is a scalable, time-based difficulty system. Early in the game, enemies are fewer and simple. As time passes, tougher enemies spawn more frequently, and new types like speed zombies can be introduced later in the game. The ScriptableObjects makes tuning and playtesting much easier since it allows me to adjust how long each phase lasts, or how frequently each enemy type spawns, without opening the code.

## SoundManager  
To handle all audio playback in the game, I created a simple `SoundManager` singleton. It supports both one-shot sound effects and looping background tracks. Sounds are referenced through an enum (`SoundType`) and matched to clips via an array in the inspector. This made it super easy to play sounds like XP pickup, level-up, or UI selects with a single line of code.
```csharp
private void LevelUp()
{
    SoundManager.PlaySound(SoundType.LEVEL_UP);
...
``` 
The manager separates music and soud effects into different `AudioSources` to better control the volume.

## Conclusion  
This milestone brought together key gameplay progression elements, all powered by ScriptableObjects. With weapon leveling, evolving enemy waves, and audio, the game now feels complete and fully playable.
